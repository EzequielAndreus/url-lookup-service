"""Malware checker orchestrator that coordinates multiple database loaders."""

import asyncio
import time

from src.models.malware_db import LoaderStatistics
from src.services.database_loaders.base import BaseLoader, ThreatInfo
from src.utils.cache import url_cache
from src.utils.logging import get_logger

logger = get_logger(__name__)


class MalwareChecker:
    """Orchestrates queries across multiple malware databases."""

    def __init__(self, loaders: list[BaseLoader], cache_enabled: bool = True):
        """Initialize the malware checker.

        Args:
            loaders: List of database loaders to query.
            cache_enabled: Whether to cache results.
        """
        self.loaders = loaders
        self.cache_enabled = cache_enabled
        self.statistics: dict[str, LoaderStatistics] = {
            loader.name: LoaderStatistics(name=loader.name) for loader in loaders
        }

    async def initialize(self) -> None:
        """Initialize all loaders (called at app startup)."""
        logger.info(f"Initializing {len(self.loaders)} malware database loaders...")

        tasks = [loader.initialize() for loader in self.loaders]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for loader, result in zip(self.loaders, results, strict=True):
            if isinstance(result, Exception):
                logger.error(f"Failed to initialize {loader.name}: {result}")
            else:
                logger.info(f"Initialized {loader.name}: {loader.is_ready()}")

    async def shutdown(self) -> None:
        """Shutdown all loaders (called at app shutdown)."""
        logger.info("Shutting down malware database loaders...")

        tasks = [loader.shutdown() for loader in self.loaders]
        await asyncio.gather(*tasks, return_exceptions=True)

    async def check_url(
        self, hostname: str, port: int = 80, path: str = "/"
    ) -> tuple[bool, list[str], dict]:
        """Check if URL is malicious across all databases.

        Args:
            hostname: The hostname to check.
            port: The port number.
            path: The URL path.

        Returns:
            Tuple of (is_malicious, databases_queried, result_details).
        """
        # Construct cache key
        cache_key = f"{hostname}:{port}{path}"

        # Check cache first
        if self.cache_enabled:
            cached_result = url_cache.get(cache_key)
            if cached_result is not None:
                logger.debug(f"Cache hit for {cache_key}: {cached_result}")
                return cached_result, [], {"cached": True}

        # Query all loaders in parallel
        start_time = time.time()
        loader_tasks = [self._query_loader(loader, hostname, port, path) for loader in self.loaders]
        loader_results = await asyncio.gather(*loader_tasks, return_exceptions=True)
        elapsed_ms = (time.time() - start_time) * 1000

        # Process results
        is_malicious = False
        databases_queried = []
        threat_details = {}

        for loader, result in zip(self.loaders, loader_results, strict=True):
            if isinstance(result, Exception):
                logger.error(f"Error querying {loader.name}: {result}")
                self.statistics[loader.name].failed_queries += 1
                continue

            databases_queried.append(loader.name)
            self.statistics[loader.name].successful_queries += 1
            self.statistics[loader.name].total_queries += 1
            self.statistics[loader.name].last_query_time = time.time()

            if result.is_malicious:
                is_malicious = True
                threat_details = {
                    "threat_type": result.threat_type,
                    "threat_level": result.threat_level,
                    "confidence_score": result.confidence_score,
                    "detected_by": result.detected_by,
                }
                self.statistics[loader.name].malicious_urls_found += 1

        # Cache the result
        if self.cache_enabled:
            url_cache.set(cache_key, is_malicious)

        # Update statistics
        for stats in self.statistics.values():
            if stats.total_queries > 0:
                stats.avg_response_time_ms = elapsed_ms / len(self.loaders)

        logger.info(
            f"URL check: {cache_key} -> is_malicious={is_malicious}, "
            f"databases={databases_queried}, response_time={elapsed_ms:.2f}ms"
        )

        result_details = {
            "cached": False,
            "response_time_ms": elapsed_ms,
            **threat_details,
        }

        return is_malicious, databases_queried, result_details

    async def _query_loader(
        self, loader: BaseLoader, hostname: str, port: int, path: str
    ) -> ThreatInfo | None:
        """Query a single loader with timeout.

        Args:
            loader: The loader to query.
            hostname: The hostname.
            port: The port.
            path: The path.

        Returns:
            ThreatInfo from the loader.
        """
        try:
            return await asyncio.wait_for(
                loader.lookup(hostname, port, path),
                timeout=loader.timeout_seconds,
            )
        except TimeoutError:
            logger.warning(f"{loader.name} lookup timed out")
            return ThreatInfo(
                is_malicious=False,
                detected_by=loader.name,
                metadata={"error": "timeout"},
            )

    def get_statistics(self) -> dict[str, LoaderStatistics]:
        """Get statistics for all loaders."""
        return self.statistics

    def get_loader(self, name: str) -> BaseLoader | None:
        """Get a specific loader by name."""
        for loader in self.loaders:
            if loader.name == name:
                return loader
        return None

    def is_ready(self) -> bool:
        """Check if any loader is ready."""
        return any(loader.is_ready() for loader in self.loaders)

    def get_status(self) -> dict:
        """Get current status of all loaders."""
        return {
            "ready": self.is_ready(),
            "loaders": [
                {
                    "name": loader.name,
                    "ready": loader.is_ready(),
                    "type": loader.__class__.__name__,
                }
                for loader in self.loaders
            ],
            "cache_enabled": self.cache_enabled,
            "cache_size": url_cache.size(),
        }
