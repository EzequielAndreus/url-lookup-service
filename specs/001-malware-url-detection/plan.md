# Implementation Plan: Malware URL Detection API

**Branch**: `001-malware-url-detection` | **Date**: 2025-12-30 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-malware-url-detection/spec.md`

## Summary

Build a simple, high-performance HTTP API that validates URLs and checks them against multiple malware databases. The API accepts requests via `GET /urlinfo/1/{hostname_and_port}/{original_path_and_query_string}`, validates URL format, queries malware databases asynchronously, and returns a simple JSON response (true/false for malicious). FastAPI handles concurrent requests natively with async/await, with optional caching for repeated lookups. Multi-database support through pluggable loader pattern. Fully tested (edge cases, input validation, performance) with transparent logging throughout.

## Technical Context

**Language/Version**: Python 3.11+  
**Primary Dependencies**: FastAPI, pydantic, httpx (async HTTP client), aiofiles (async file I/O), pytest (testing)
**Storage**: Multi-database support - files (CSV/JSON) or HTTP endpoints for external malware databases
**Testing**: pytest with pytest-asyncio for async tests, performance benchmarking via locust or similar
**Target Platform**: Linux server, MacOS (local development) - platform-agnostic Python
**Project Type**: Single backend service (REST API)
**Performance Goals**: 500ms p95 latency for URL lookup, 100+ concurrent requests without blocking
**Constraints**: <500MB memory for typical deployment, graceful degradation when database unavailable
**Scale/Scope**: MVP supports multi-database abstraction; extensible for millions of URLs via caching and database optimization

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Gate Evaluation vs Constitution Principles

| Principle | Requirement | Status | Evidence |
|-----------|-------------|--------|----------|
| **I. Comprehensive Testing** | Edge cases, input validation, performance tests mandatory | ✅ PASS | Spec includes 7 edge cases, input validation scenarios (S2), performance tests (S3). Tests organized by type in tasks. |
| **II. Workflow Transparency** | Clear logging, non-opaque errors, async operation tracking | ✅ PASS | FR-008 requires audit logging with context. Error responses specify failure reason (FR-003). Plan includes logging infrastructure. |
| **III. Incremental Changes** | Simple, focused increments; one requirement per task | ✅ PASS | Three user stories (P1 core, P1 validation, P2 performance) can be implemented independently. Spec uses YAGNI principle. |
| **IV. Scalability & Reliability** | Async architecture, connection limits, graceful degradation | ✅ PASS | FastAPI async-native. FR-009 requires graceful DB failure handling. FR-006 handles concurrent requests. Resource pooling in database loaders. |
| **V. Asynchronous API Design** | Non-blocking handlers, async I/O, error handling in async contexts | ✅ PASS | FastAPI with async/await throughout. httpx async client for DB queries. FR-004 specifies async database queries. aiofiles for file I/O. |

**Gate Result**: ✅ **APPROVED** - Plan aligns with all five constitution principles. No violations or justifications needed.

**Re-evaluation scheduled**: After Phase 1 design (data-model.md and contracts/) completion.

## Project Structure

### Documentation (this feature)

```text
specs/001-malware-url-detection/
├── plan.md                 # This file (implementation plan)
├── spec.md                 # Feature specification
├── research.md             # Phase 0 - research findings (GENERATED)
├── data-model.md           # Phase 1 - entities and relationships (GENERATED)
├── quickstart.md           # Phase 1 - development guide (GENERATED)
├── contracts/              # Phase 1 - API contracts (GENERATED)
│   └── urlinfo.md          # GET /urlinfo/1/{hostname_and_port}/{path} contract
├── checklists/
│   └── requirements.md     # Quality checklist (COMPLETED)
└── tasks.md                # Phase 2 - task breakdown (NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
src/
├── main.py                 # FastAPI app initialization and route mounting
├── models/
│   ├── url_check.py        # Pydantic models: URLCheckRequest, URLCheckResponse
│   └── malware_db.py       # Database entity models
├── services/
│   ├── url_validator.py    # URL format validation, normalization
│   ├── malware_checker.py  # Orchestrator for multi-database lookup
│   └── database_loaders/
│       ├── base.py         # Abstract loader interface
│       ├── file_loader.py  # Load malware URLs from local files (CSV/JSON)
│       └── http_loader.py  # Load malware URLs from HTTP endpoints
├── api/
│   └── urlinfo.py          # FastAPI router for /urlinfo/1/{hostname_and_port}/{path}
├── utils/
│   ├── logging.py          # Structured logging helpers
│   └── cache.py            # Optional response caching
└── config.py               # Configuration management (database sources, cache settings)

tests/
├── contract/
│   └── test_urlinfo_contract.py     # API contract tests (request/response format)
├── integration/
│   ├── test_malware_detection.py    # End-to-end URL checking workflow
│   └── test_database_loaders.py     # Multi-database loading integration
├── unit/
│   ├── test_url_validator.py        # URL format validation edge cases
│   ├── test_malware_checker.py      # Logic tests with mocked databases
│   └── test_url_normalization.py    # URL format variations (http/https, etc.)
├── fixtures/
│   ├── sample_malware_urls.csv      # Test data for file loader
│   ├── sample_malware_urls.json     # Alternative test data format
│   └── mock_http_server.py          # Mock HTTP database endpoint for testing
└── conftest.py             # pytest configuration and shared fixtures
```

**Structure Decision**: Single backend service with modular organization. Database loaders use pluggable interface for multi-database support (files, HTTP endpoints, future SQL databases). Tests organized by scope (contract, integration, unit) per constitution testing requirements. Platform-agnostic Python code runs on Linux and MacOS unchanged.

## Next Steps

1. **Phase 0 - Research**: Run agent research on multi-database patterns and async caching
2. **Phase 1 - Design**: Generate data-model.md, contracts/, and quickstart.md
3. **Phase 1 - Agent Context**: Run update-agent-context.sh to sync FastAPI, pytest, and architecture with agent
4. **Re-evaluate Constitution**: Confirm design aligns with principles post-design
5. **Phase 2 - Tasks**: Run `/speckit.tasks` to generate implementation task breakdown by user story
